gestire path non previsti.

{
"foo":{
"name":"bar"
}
}
Expression: foo.dude?.bananas e foo.dude.bananas
Result: null


foo["name"]
ma ci sono svariate cose qui da dire
zio billy come temevo ðŸ™‚
ne avevamo anche parlato, ma in realtÃ  se la funzione Ã¨ scritta bene, non dovrebbe cambiare un gran che
se la funzione Ã¨ implementata come un _memento_ , la cosa dovrebbe essere semplice.
mi spiego.
one.two.three
un memento saprebbe il suo segmento corrente il blocco che gli manca
per capirci:
```
navigate(current,remaining,scope)
```
e lasciare che la iterazione precedente decida qual Ã¨ l'oggetto corrente
simuliamo per esempio che noi si debba navigare, con questo prototipo:
```
{
"foo":{
"foo-bar":{
}
}
```


esatto, e inoltre
le espressioni sono scritte dall'utente
e se l'utente vuole scrivere
foo["foo-bar"]["name"]
foo["foo-bar"].namne
vanno gestite anche le dure robe sopra


mappe:
c['a']
c["a"]
c[var]
foo[variabile]


